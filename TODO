TODO: this TODO list is out of date
TODO: In no particular order.
general
 1. Fix Makefile (.d's seem to be somewhat screwy, and test get's made always...)
     Note there may not be a way to make this stop, it's just make generating errors
     when the autogenerated dependancies are not present...  - FIXED
 2. When bytecode is changed make clean is neccessary or compile errors will happen
 
interpreter
 1. add conditional compilation to headers for C++ compiling - DONE!
 3. figure out how to make eclipse build our test case - DONE!
 4. finish API - DONE!
 5. add test cases for entire API
 6. add test cases for all instructions 
 7. Figure out some way to allow interpreter to be terminated if it goes into an
    infinite loop.
 8. figure out how to make debug hooks
 9. 
 
 Change integer max and min, And add a check to configure to see if we have signed shifts.
Integer Minimum or Maximum

Given 2's complement integer values x and y, the minimum can be computed without any branches as x+(((y-x)>>(WORDBITS-1))&(y-x)). Logically, this works because the shift by (WORDBITS-1) replicates the sign bit to create a mask -- be aware, however, that the C language does not require that shifts are signed even if their operands are signed, so there is a potential portability problem. Additionally, one might think that a shift by any number greater than or equal to WORDBITS would have the same effect, but many instruction sets have shifts that behave strangely when such shift distances are specified. 

Of course, maximum can be computed using the same trick: x-(((x-y)>>(WORDBITS-1))&(x-y)). 

Actually, the Integer Selection coding trick is just as efficient in encoding minimum and maximum....


 
======

-- write documentation (Overview/Tutorial)
-- document external API in headers - DONE!


